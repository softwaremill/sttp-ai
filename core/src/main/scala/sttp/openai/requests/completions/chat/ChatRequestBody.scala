package sttp.openai.requests.completions.chat

import sttp.openai.OpenAIExceptions.OpenAIException.DeserializationOpenAIException
import sttp.openai.json.SnakePickle
import sttp.openai.requests.completions.Stop
import ujson.{Arr, Obj, Str, Value}

object ChatRequestBody {
  sealed trait Message

  object Message {

    /** @param content
      *   The contents of the system message.
      * @param role
      *   The role of the messages author, in this case system.
      * @param name
      *   An optional name for the participant. Provides the model information to differentiate between participants of the same role.
      */
    case class SystemMessage(content: String, role: Role, name: Option[String] = None) extends Message

    /** @param content
      *   The contents of the system message.
      * @param role
      *   The role of the messages author, in this case user.
      * @param name
      *   An optional name for the participant. Provides the model information to differentiate between participants of the same role.
      */
    case class UserMessage(content: Content, role: Role, name: Option[String] = None) extends Message

    /** @param content
      *   The contents of the system message.
      * @param role
      *   The role of the messages author, in this case assistant.
      * @param name
      *   An optional name for the participant. Provides the model information to differentiate between participants of the same role.
      * @param toolCalls
      *   The tool calls generated by the model, such as function calls.
      */
    case class AssistantMessage(content: String, role: Role, name: Option[String] = None, toolCalls: Option[Seq[ToolCall]] = None)
        extends Message

    /** @param content
      *   The contents of the system message.
      * @param role
      *   The role of the messages author, in this case tool.
      * @param toolCallId
      *   Tool call that this message is responding to.
      */
    case class ToolMessage(content: String, role: Role, toolCallId: String) extends Message

    sealed trait Content
    sealed trait ContentPart

    object Content {
      case class TextContent(value: String) extends Content

      case class ArrayContent(value: Seq[ContentPart]) extends Content

      case class TextContentPart(`type`: String, text: String) extends ContentPart

      case class ImageContentPart(`type`: String, image: String) extends ContentPart

      implicit val contentRW: SnakePickle.ReadWriter[Content] = SnakePickle
        .readwriter[ujson.Value]
        .bimap[Content](
          {
            case TextContent(value)  => SnakePickle.writeJs(value)
            case ArrayContent(value) => SnakePickle.writeJs(value)
          },
          jsonValue =>
            SnakePickle.read[ujson.Value](jsonValue) match {
              case Str(value) => TextContent(value)
              case Arr(value) => ArrayContent(value.toSeq.map(SnakePickle.read[ContentPart](_)))
              case e          => throw DeserializationOpenAIException(new Exception(s"Could not deserialize: $e"))
            }
        )

      implicit val contentPartRW: SnakePickle.ReadWriter[ContentPart] = SnakePickle.ReadWriter.merge(
        SnakePickle.macroRW[TextContentPart],
        SnakePickle.macroRW[ImageContentPart]
      )
    }

    implicit val messageRW: SnakePickle.ReadWriter[Message] = SnakePickle.ReadWriter.merge(
      SnakePickle.macroRW[SystemMessage],
      SnakePickle.macroRW[UserMessage],
      SnakePickle.macroRW[AssistantMessage],
      SnakePickle.macroRW[ToolMessage]
    )
  }

  /** @param type
    *   The type of the tool. Currently, only function is supported.
    */
  case class Tool(`type`: String, function: Tool.FunctionCall)

  object Tool {

    /** @param description
      *   A description of what the function does, used by the model to choose when and how to call the function.
      * @param name
      *   The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
      * @param parameters
      *   The parameters the functions accepts, described as a JSON Schema object
      */
    case class FunctionCall(description: String, name: String, parameters: Map[String, Value])

    object FunctionCall {
      implicit val functionCallRW: SnakePickle.ReadWriter[FunctionCall] = SnakePickle.macroRW[FunctionCall]
    }

    implicit val toolRW: SnakePickle.ReadWriter[Tool] = SnakePickle.macroRW[Tool]
  }

  sealed trait ToolChoice

  object ToolChoice {
    case class AsString(value: String) extends ToolChoice

    case class AsObject(`type`: Option[String] = None, function: Option[FunctionSpec] = None) extends ToolChoice

    case class FunctionSpec(name: String)
    object FunctionSpec {
      implicit val functionSpecRW: SnakePickle.ReadWriter[FunctionSpec] = SnakePickle.macroRW[FunctionSpec]
    }

    implicit val toolChoiceRW: SnakePickle.ReadWriter[ToolChoice] = SnakePickle
      .readwriter[ujson.Value]
      .bimap[ToolChoice](
        {
          case AsString(value) => SnakePickle.writeJs(value)
          case o: AsObject     => SnakePickle.writeJs(o)
        },
        jsonValue =>
          SnakePickle.read[ujson.Value](jsonValue) match {
            case Str(value) => AsString(value)
            case Obj(value) => SnakePickle.read[AsObject](value)
            case e          => throw DeserializationOpenAIException(new Exception(s"Could not deserialize: $e"))
          }
      )

    implicit val asObjectRW: SnakePickle.ReadWriter[AsObject] = SnakePickle.macroRW[AsObject]
  }

  case class ResponseFormat(`type`: String)

  object ResponseFormat {
    implicit val responseFormatRW: SnakePickle.ReadWriter[ResponseFormat] = SnakePickle.macroRW[ResponseFormat]
  }

  /** @param messages
    *   A list of messages describing the conversation so far.
    * @param model
    *   ID of the model to use.
    * @param frequencyPenalty
    *   Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing
    *   the model's likelihood to repeat the same line verbatim.
    * @param logitBias
    *   Modify the likelihood of specified tokens appearing in the completion.
    * @param maxTokens
    *   The maximum number of tokens to generate in the chat completion.
    * @param n
    *   How many chat completion choices to generate for each input message.
    * @param presencePenalty
    *   Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the
    *   model's likelihood to talk about new topics.
    * @param responseFormat
    *   An object specifying the format that the model must output. Setting to {"type": "json_object"} enables JSON mode, which guarantees
    *   the message the model generates is valid JSON.
    * @param seed
    *   This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests
    *   with the same seed and parameters should return the same result. Determinism is not guaranteed, and you should refer to the
    *   system_fingerprint response parameter to monitor changes in the backend.
    * @param stop
    *   Up to 4 sequences where the API will stop generating further tokens.
    * @param temperature
    *   What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like
    *   0.2 will make it more focused and deterministic.
    * @param topP
    *   An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p
    *   probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
    * @param tools
    *   A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the
    *   model may generate JSON inputs for.
    * @param toolChoice
    *   Controls which (if any) function is called by the model. "none" means the model will not call a function and instead generates a
    *   message. "auto" means the model can pick between generating a message or calling a function. Specifying a particular function via
    *   `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that function. "none" is the default when no
    *   functions are present. "auto" is the default if functions are present.
    * @param user
    *   A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse.
    */
  case class ChatBody(
      messages: Seq[Message],
      model: ChatCompletionModel,
      frequencyPenalty: Option[Double] = None,
      logitBias: Option[Map[String, Float]] = None,
      maxTokens: Option[Int] = None,
      n: Option[Int] = None,
      presencePenalty: Option[Double] = None,
      responseFormat: Option[ResponseFormat] = None,
      seed: Option[Int] = None,
      stop: Option[Stop] = None,
      temperature: Option[Double] = None,
      topP: Option[Double] = None,
      tools: Option[Seq[Tool]] = None,
      toolChoice: Option[ToolChoice] = None,
      user: Option[String] = None
  )

  object ChatBody {
    def withStreaming(chatBody: ChatBody): ujson.Value = {
      val json = SnakePickle.writeJs(chatBody)
      json.obj("stream") = true
      json
    }

    implicit val chatRequestW: SnakePickle.Writer[ChatBody] = SnakePickle.macroW[ChatBody]
  }

  sealed abstract class ChatCompletionModel(val value: String)

  object ChatCompletionModel {
    implicit val chatCompletionModelRW: SnakePickle.ReadWriter[ChatCompletionModel] = SnakePickle
      .readwriter[ujson.Value]
      .bimap[ChatCompletionModel](
        model => SnakePickle.writeJs(model.value),
        jsonValue =>
          SnakePickle.read[ujson.Value](jsonValue) match {
            case Str(value) =>
              byChatModelValue.getOrElse(value, throw DeserializationOpenAIException(new Exception(s"Could not deserialize: $value")))
            case e => throw DeserializationOpenAIException(new Exception(s"Could not deserialize: $e"))
          }
      )

    case object GPT4 extends ChatCompletionModel("gpt-4")

    case object GPT40314 extends ChatCompletionModel("gpt-4-0314")

    case object GPT432k extends ChatCompletionModel("gpt-4-32k")

    case object GPT432k0314 extends ChatCompletionModel("gpt-4-32k-0314")

    case object GPT35Turbo extends ChatCompletionModel("gpt-3.5-turbo")

    case object GPT35Turbo0301 extends ChatCompletionModel("gpt-3.5-turbo-0301")

    case object GPT4Turbo extends ChatCompletionModel("gpt-4-1106-preview")

    case object GPT4TurboVision extends ChatCompletionModel("gpt-4-vision-preview")

    case class CustomChatCompletionModel(customChatCompletionModel: String) extends ChatCompletionModel(customChatCompletionModel)

    val values: Set[ChatCompletionModel] =
      Set(
        GPT4,
        GPT40314,
        GPT432k,
        GPT432k0314,
        GPT35Turbo,
        GPT35Turbo0301,
        GPT4Turbo,
        GPT4TurboVision
      )

    private val byChatModelValue = values.map(model => model.value -> model).toMap
  }

}
